{"version":3,"file":"frameport.js","sources":["src/utils/iframe.ts","src/utils/source.ts","src/utils/css.ts","src/utils/js.ts","src/utils/code.ts","src/utils/style.ts","src/utils/page.ts","src/utils/blob.ts","src/utils/styles.ts","src/utils/wait.ts","src/utils/create.ts","src/utils/constants.ts","src/features/dom.ts","src/config/generate-viewports.ts","src/config/generate.ts","src/utils/headers.ts","src/config/browser.ts","src/main.ts"],"sourcesContent":["/**\n * Create and return an iframe element.\n *\n * @returns {HTMLIFrameElement} - The created iframe element.\n */\nexport const createIframe = (): HTMLIFrameElement => document.createElement('iframe');\n","import { getCode } from './code';\nimport { getCSS } from './css';\nimport { getJavaScript } from './js';\nimport { FrameportOptions } from '../types';\nimport { getStyle } from './style';\n\n/**\n * Generate the source code for an HTML page based on the provided options.\n *\n * @param {FrameportOptions} options - The options for generating the HTML page source.\n * @returns {string} - The generated HTML source code as a string.\n */\nexport const getSource = (options: FrameportOptions): string => {\n  let { html, style, css, code, javascript, headers = [] } = options;\n\n  css = getCSS(css);\n  javascript = getJavaScript(javascript);\n  code = getCode(code);\n  style = getStyle(style);\n\n  return `<!DOCTYPE html><html>\n  <head>\n    ${headers.join('\\n')}\n    ${style}\n    ${css}\n  </head>\n  <body>\n    ${html || ''}\n    ${javascript}\n    ${code}\n  </body>\n</html>`;\n};\n","/**\n * Generate a CSS link tag based on the provided URL.\n *\n * @param {string | undefined} css - The URL of the CSS file.\n * @returns {string} - A CSS link tag.\n */\nexport const getCSS = (css: string | undefined): string => {\n  if (css) {\n    return `<link rel=\"stylesheet\" type=\"text/css\" href=\"${window.location.protocol}//${window.location.host}${css}\" />`;\n  }\n  return '';\n};\n","/**\n * Generate a script tag for the specified JavaScript file.\n *\n * @param {string | undefined} javascript - The path to the JavaScript file.\n * @returns {string} - The generated script tag or an empty string if no JavaScript path is provided.\n */\nexport const getJavaScript = (javascript: string | undefined): string => {\n  if (javascript) {\n    return `<script src=\"${window.location.protocol}//${window.location.host}${javascript}\"></script>`;\n  }\n  return '';\n};\n","/**\n * Get a script element containing the provided code if available.\n *\n * @param {string | undefined} code - The code to include in the script element.\n * @returns {string} - The script element or an empty string if code is not available.\n */\nexport const getCode = (code: string | undefined): string => {\n  if (code) {\n    return `<script>${code}</script>`;\n  }\n  return '';\n};\n","/**\n * Generate a style element based on the provided CSS styles.\n *\n * @param {string | undefined} style - The CSS styles to include in the style element.\n * @returns {string} - The style element as a string or an empty string if no styles are provided.\n */\nexport const getStyle = (style: string | undefined): string => {\n  if (style) {\n    return `<style type=\"text/css\">\n    ${style}\n  </style>`;\n  }\n  return '';\n};\n","import { getBlobURL } from \"./blob\";\nimport { getSource } from \"./source\";\n\n/**\n * Get the URL of a generated HTML page based on the provided options.\n *\n * @param {object} options - The options for generating the HTML page.\n * @returns {string} - The URL of the generated HTML page as a Blob URL.\n */\nexport const getGeneratedPageURL = (options) => {\n  const source = getSource(options);\n  return getBlobURL(source, 'text/html');\n};\n","/**\n * Generates a Blob URL from HTML content with the specified MIME type.\n *\n * @param {string} html - The HTML content to create a Blob from.\n * @param {string} type - The MIME type of the Blob (e.g., 'text/html', 'image/jpeg').\n * @returns {string} - The generated Blob URL.\n */\nexport const getBlobURL = (html: string, type: string): string => {\n  const blob = new Blob([html], { type });\n  return URL.createObjectURL(blob);\n};\n","/* eslint no-console:0 */\n'use strict';\nimport { waitForFrame } from './wait';\n\n/**\n * Adds CSS styles to an HTMLElement.\n *\n * @param {HTMLElement} el - The HTMLElement to apply styles to.\n * @param {object | Array<{ key: string; value: string }>} styles - An object or an array of objects containing CSS styles to apply.\n * @returns {Promise<void>} - A Promise that resolves after styles are applied.\n *\n * @example\n * ```ts\n * // Apply styles as an object\n * const element = document.getElementById('my-element');\n * await add(element, { color: 'red', fontSize: '16px' });\n *\n * // Apply styles as an array of objects\n * const styles = [\n *   { key: 'color', value: 'blue' },\n *   { key: 'backgroundColor', value: 'yellow' }\n * ];\n * await add(element, styles);\n * ```\n */\nexport const add = async (\n  el: HTMLElement,\n  styles: object | Array<{ key: string; value: string }>\n): Promise<void> => {\n  if (\n    !el ||\n    !styles ||\n    typeof styles === 'string' ||\n    typeof styles === 'number' ||\n    typeof styles === 'boolean' ||\n    (Array.isArray(styles) && styles.length === 0) ||\n    (Object.keys(styles).length === 0 && styles.constructor === Object)\n  ) {\n    return;\n  }\n\n  await waitForFrame();\n\n  if (Array.isArray(styles)) {\n    styles.forEach(\n      (style: { key: string; value: string }) =>\n        (el.style[style.key] = style.value)\n    );\n  } else {\n    Object.keys(styles).forEach((key) => (el.style[key] = styles[key]));\n  }\n};\n\n/**\n * Gets the computed CSS styles of an HTMLElement.\n *\n * @param {HTMLElement} el - The HTMLElement to get computed styles from.\n * @returns {Promise<CSSStyleDeclaration>} - A Promise that resolves with the computed CSS styles.\n *\n * @example\n * ```ts\n * // Get computed styles of an element\n * const element = document.getElementById('my-element');\n * const computedStyles = await get(element);\n * console.log(computedStyles.color); // Logs the color property value\n * ```\n */\nexport const get = async (el: HTMLElement): Promise<CSSStyleDeclaration> => {\n  await waitForFrame();\n\n  return getComputedStyle(el, null);\n};\n","/**\n * Waits for the specified amount of time in milliseconds.\n *\n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} - A Promise that resolves after the specified time.\n *\n * @example\n * ```ts\n * // Wait for 1 second (1000 milliseconds)\n * await waitFor(1000);\n * ```\n */\nexport const waitFor = (ms: number): Promise<void> =>\n  new Promise<void>((resolve) => setTimeout(resolve, ms));\n\n/**\n * Waits for the next animation frame using requestAnimationFrame.\n *\n * @returns {Promise<number>} - A Promise that resolves with the timestamp of the next animation frame.\n *\n * @example\n * ```ts\n * // Wait for the next animation frame and get the rect\n * await waitForFrame();\n * const rect = el.getBoundingClientRect();\n * // Wait for the next animation frame and get the timestamp\n * const timestamp = await waitForFrame();\n * ```\n */\nexport const waitForFrame = (): Promise<number> =>\n  new Promise<number>(requestAnimationFrame);\n","import { FrameportOptions } from 'types';\nimport { createIframe } from 'utils/iframe';\nimport { getGeneratedPageURL } from 'utils/page';\nimport { add as addStyles } from 'utils/styles';\n\n/**\n * Create an iframe element with specified options and styles.\n *\n * @param {FrameportOptions} options - The options for creating the iframe.\n * @returns {HTMLIFrameElement} - The created iframe element.\n */\nexport const create = (\n  options: FrameportOptions\n): HTMLIFrameElement => {\n  const { className, height, width } = options;\n  const url = getGeneratedPageURL(options);\n  const iframeElement = createIframe();\n  const iframeStyle = {};\n\n  iframeElement.src = url;\n  iframeElement.setAttribute('data-rde-iframe', '');\n\n  if (!className || className === '') {\n    iframeStyle['border'] = 'none';\n  } else {\n    iframeElement.classList.add(className);\n  }\n\n  iframeStyle['width'] = `${width}px`;\n\n  if (height) {\n    iframeStyle['height'] = `${height}px`;\n  }\n\n  addStyles(iframeElement, iframeStyle);\n\n  return iframeElement;\n};\n","/**\n * Style object for hiding an element in the HTML.\n *\n * @type {{ clip: string, height: string, margin: string, overflow: string, position: string, width: string }}\n */\nexport const HIDE_TEMPLATE_STYLE: { clip: string; height: string; margin: string; overflow: string; position: string; width: string; } = {\n  clip: 'rect(1px, 1px, 1px, 1px)',\n  height: '1px',\n  margin: '0',\n  overflow: 'hidden',\n  position: 'absolute',\n  width: '1px'\n};\n\n/**\n * Default meta headers for an HTML document.\n *\n * @type {string[]}\n */\nexport const DEFAULT_HEADERS: string[] = [\n  '<meta charset=\"utf-8\" />',\n  '<meta name=\"robots\" content=\"none\" />',\n  '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />',\n  '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />'\n];\n","import { generate } from 'config/generate';\nimport { generateViewports } from 'config/generate-viewports';\nimport { FrameportOptions } from 'types';\nimport { HIDE_TEMPLATE_STYLE } from 'utils/constants';\nimport { add as addStyles } from 'utils/styles';\n\n/**\n * Generate iframes into the DOM, possibly generating viewports.\n *\n * @param {HTMLElement} targetElement - The target HTML element.\n * @param {FrameportOptions} options - The options for the iframe.\n * @returns {void}\n */\nconst dom = (\n  targetElement: HTMLElement,\n  options: FrameportOptions\n): void => {\n  if (\n    !targetElement ||\n    !options ||\n    (options && Object.keys(options).length === 0)\n  )\n    return;\n\n  const { html, viewports, templateElement } = options;\n\n  if (!html || html === '') return;\n\n  addStyles(templateElement as HTMLElement, HIDE_TEMPLATE_STYLE);\n\n  if (viewports) {\n    generateViewports(targetElement, options);\n  } else {\n    generate(targetElement, options);\n  }\n};\n\nexport default dom;\n","import { FrameportOptions } from 'types';\nimport { create } from 'utils/create';\n\n/**\n * Generate multiple iframe elements for different viewports and append them to a target element.\n *\n * @param {HTMLElement} target - The target HTML element to insert iframes after.\n * @param {FrameportOptions} options - The options for generating the iframes.\n * @returns {void}\n */\nexport const generateViewports = (\n  target: HTMLElement,\n  options: FrameportOptions\n): void => {\n  const { viewports } = options;\n\n  if (!viewports || viewports === '') return;\n\n  let screens: string[] = [];\n\n  if (viewports.indexOf(',') !== -1) {\n    screens = [...screens, ...viewports.split(',')];\n  } else {\n    screens.push(viewports);\n  }\n\n  screens.forEach((viewPort: string) => {\n    const values = viewPort.split('x');\n    const width = values[0];\n    const height = values[1];\n\n    const iframeElement = create({ ...options, height, width });\n\n    target.insertAdjacentElement('afterend', iframeElement);\n  });\n};\n","import { FrameportOptions } from 'types';\nimport { create } from 'utils/create';\n\n/**\n * Generate an iframe with the given options and append it to a target element.\n *\n * @param {HTMLElement} targetElement - The target HTML element to append the iframe to.\n * @param {FrameportOptions} options - The options for generating the iframe.\n * @returns {void}\n */\nexport const generate = (\n  targetElement: HTMLElement,\n  options: FrameportOptions\n): void => {\n  const { width } = options;\n\n  if (!width) return;\n\n  const iframeElement = create(options);\n\n  targetElement.append(iframeElement);\n};\n","import { DEFAULT_HEADERS } from \"./constants\";\n\n/**\n * Get headers for the iframe generated\n *\n * @param {string|string[]|null|undefined} rdeHeaders - The custom headers to include.\n * @returns {string[]} - An array of headers, including default and custom headers.\n */\nexport const getHeaders = (rdeHeaders: string | string[] | null | undefined): string[] => {\n  let headers: string[] = [...DEFAULT_HEADERS];\n\n  if (rdeHeaders) {\n    if (Array.isArray(rdeHeaders)) {\n      headers = [...headers, ...rdeHeaders];\n    } else if (rdeHeaders.indexOf(',') !== -1) {\n      headers = [...headers, ...rdeHeaders.split(',')];\n    } else if (rdeHeaders !== '') {\n      headers.push(rdeHeaders);\n    }\n  }\n\n  return headers;\n};\n","/* eslint no-console:0 */\n'use strict';\n\nimport { FrameportFunctionType } from 'types';\nimport dom from 'features/dom';\nimport { getHeaders } from 'utils/headers';\n\n/**\n * A function to initialize frameport when the DOM is ready.\n *\n * @param {FrameportFunctionType} frameport - The frameport function to execute.\n *\n * @example\n * ```ts\n * // Usage example:\n * // domReady(myRDE);\n * ```\n */\nexport const domReady = (\n  frameport: FrameportFunctionType\n): void => {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      frameport();\n    });\n  } else {\n    // `DOMContentLoaded` already fired\n    frameport();\n  }\n};\n\n/**\n * A function to initialize lazy frameport functionality.\n *\n * @example\n * ```ts\n * // Usage example:\n * // lazy();\n * ```\n */\nexport const lazy = (): void => {\n  const frameportObserverTarget = new IntersectionObserver((els, observer) => {\n    els.forEach((el: IntersectionObserverEntry) => {\n      if (el.intersectionRatio > 0) {\n        const {\n          dataset: {\n            frameportTemplate: templateSelector,\n            frameportVh: height,\n            frameportVw: width,\n            frameportCss: css,\n            frameportStyle: style,\n            frameportCode: code,\n            frameportJs: javascript,\n            frameportClass: className,\n            frameportHeaders: headers,\n            frameportViewports: viewports,\n          },\n        } = el.target as HTMLElement;\n\n        let html = el.target.innerHTML;\n        let templateElementToUse = el.target as HTMLElement;\n\n        if (templateSelector) {\n          const templateElement = document.querySelector(templateSelector);\n\n          if (templateElement) {\n            html = templateElement.innerHTML;\n            templateElementToUse = templateElement as HTMLElement;\n          }\n        }\n\n        const options = {\n          templateSelector,\n          templateElement: templateElementToUse,\n          height,\n          width,\n          html,\n          css,\n          style,\n          code,\n          javascript,\n          className,\n          headers: getHeaders(headers),\n          viewports,\n        };\n        dom(el.target as HTMLElement, options);\n        observer.unobserve(el.target);\n      }\n    });\n  });\n\n  document.querySelectorAll('[data-frameport]').forEach((el) => {\n    frameportObserverTarget.observe(el);\n  });\n};\n\n/**\n * A function to manually activate frameport.\n *\n * @param {FrameportFunctionType} frameport - The frameport function to execute.\n *\n * @example\n * ```ts\n * // Usage example:\n * // manual(myRDE);\n * ```\n */\nexport const manual = (\n  frameport: FrameportFunctionType\n): void => {\n  window.frameport = frameport;\n};\n\n/**\n * A function to activate frameport based on script attributes.\n *\n * @param {FrameportFunctionType} frameport - The frameport function to execute.\n *\n * @example\n * ```ts\n * // Usage example:\n * // activate(myRDE);\n * ```\n */\nexport const activate = (\n  frameport: FrameportFunctionType\n): void => {\n  const script = document.currentScript;\n\n  if (script) {\n    const frameportScriptSrc = script.getAttribute('src');\n\n    if (frameportScriptSrc && frameportScriptSrc.indexOf('frameport.js') !== -1) {\n      if (script.hasAttribute('data-manual')) {\n        manual(frameport);\n      } else if (script.hasAttribute('data-instant')) {\n        frameport();\n      } else if (script.hasAttribute('data-dom')) {\n        domReady(frameport);\n      } else if (script.hasAttribute('data-lazy')) {\n        lazy();\n      } else {\n        domReady(frameport);\n      }\n    }\n  }\n};\n","import { domReady, lazy, manual, activate } from 'config/browser';\nimport dom from 'features/dom';\nimport { getHeaders } from 'utils/headers';\n\nexport const modes = {\n  domReady,\n  lazy,\n  manual,\n  activate,\n};\n\nconst frameport = () => {\n  document\n    .querySelectorAll('[data-frameport-iframe]')\n    .forEach((iframe) => iframe.remove());\n\n  const elsToBeTransformedTemplate = document.querySelectorAll('[data-frameport]');\n\n  elsToBeTransformedTemplate.forEach((targetElement: HTMLElement) => {\n    const {\n      dataset: {\n        frameportTemplate: templateSelector,\n        frameportVh: height,\n        frameportVw: width,\n        frameportCss: css,\n        frameportStyle: style,\n        frameportCode: code,\n        frameportJs: javascript,\n        frameportClass: className,\n        frameportHeaders: headers,\n        frameportViewports: viewports,\n      },\n    } = targetElement;\n\n    let html = targetElement.innerHTML;\n    let templateElementToUse = targetElement;\n\n    if (templateSelector) {\n      const templateElement = document.querySelector(templateSelector);\n\n      if (templateElement) {\n        html = templateElement.innerHTML;\n        templateElementToUse = templateElement as HTMLElement;\n      }\n    }\n\n    const options = {\n      templateSelector,\n      templateElement: templateElementToUse,\n      height,\n      width,\n      html,\n      css,\n      style,\n      code,\n      javascript,\n      className,\n      headers: getHeaders(headers),\n      viewports,\n    };\n\n    dom(targetElement, options);\n  });\n};\n\nexport default frameport;\n\nactivate(frameport);\n"],"names":["getSource","options","html","style","css","code","javascript","headers","window","location","protocol","host","getCSS","getJavaScript","getCode","getStyle","join","getGeneratedPageURL","type","blob","Blob","URL","createObjectURL","getBlobURL","add","async","el","styles","Array","isArray","length","Object","keys","constructor","Promise","requestAnimationFrame","forEach","key","value","create","className","height","width","url","iframeElement","document","createElement","iframeStyle","src","setAttribute","classList","addStyles","HIDE_TEMPLATE_STYLE","clip","margin","overflow","position","DEFAULT_HEADERS","dom","targetElement","viewports","templateElement","target","screens","indexOf","split","push","viewPort","values","insertAdjacentElement","generateViewports","append","generate","getHeaders","rdeHeaders","domReady","frameport","readyState","addEventListener","lazy","frameportObserverTarget","IntersectionObserver","els","observer","intersectionRatio","dataset","frameportTemplate","templateSelector","frameportVh","frameportVw","frameportCss","frameportStyle","frameportCode","frameportJs","frameportClass","frameportHeaders","frameportViewports","innerHTML","templateElementToUse","querySelector","unobserve","querySelectorAll","observe","manual","activate","script","currentScript","frameportScriptSrc","getAttribute","hasAttribute","modes","iframe","remove"],"mappings":"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"}